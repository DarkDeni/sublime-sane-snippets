import sublime
import os, re
from zipfile import ZipFile
from xml.etree import ElementTree as etree
from tempfile import mkstemp

template      = re.compile('^---%(n)s(.*?)%(n)s---%(n)s(.*)$' % {'n': os.linesep}, re.S)
line_template = re.compile('^(.*?):\s*(.*)$')

def CDATA(text=None):
	element = etree.Element(CDATA)
	element.text = text
	return element

class TreeDumper(etree.ElementTree):
	def _write(self, file, node, encoding, namespaces):
		if node.tag is CDATA:
			text = node.text.encode(encoding)
			file.write("<![CDATA[%s]]>" % text)
		else:
			etree.ElementTree._write(self, file, node, encoding, namespaces)

def snippet_to_xml(snippet):
	s = etree.Element('snippet')
	for key in ['description', 'tabTrigger', 'scope']:
		c = etree.Element(key)
		c.text = snippet[key]
		s.append(c)
	c = etree.Element('content')
	c.append(CDATA(snippet['content']))
	s.append(c)
	return s


def parse_snippet(path, text):
	keys, snippet = [], {}

	def parse_val(text):
		# TODO: handle quoted strings.
		return text.strip()

	try:
		(frontmatter, content) = template.match(text).groups()
		snippet['content'] = content
		for line in frontmatter.split(os.linesep):
			(key, val) = line_template.match(line).groups()
			key = key.strip()
			if key in ['description', 'tabTrigger', 'scope']:
				keys.append(key)
				snippet[key] = parse_val(val)
			else:
				sublime.error_message('Unexpected YAML snippet property: "%s" in file "%s"' % (key, path))
				return
		for key in ['description', 'scope', 'tabTrigger']:
			if not key in keys:
				sublime.error_message('YAML snippet missing required property "%s" in file "%s"' % (key, path))
				return
	except Exception:
		sublime.error_message("Error parsing YAML snippet in file \"%s\"" % path)

	return snippet

def read_zip(path):
	results = []
	zipf = ZipFile(path, 'r')
	for name in zipf.namelist():
		ext = os.path.splitext(name)[-1]
		if ext == '.yaml-snippet':
			f = zipf.open(name, 'rb')
			results.append(parse_snippet(os.join(path, name), f.read()))
			f.close()
	return results

def regenerate_snippets():
	snippets = []

	# Check Packages folder
	for root, dirs, files in os.walk(sublime.packages_path()):
		for name in files:
			try:
				ext = os.path.splitext(name)[-1]
				if ext == '.yaml-snippet':
					path = os.path.join(root, name)
					f = open(path, 'rb')
					snippets.append(parse_snippet(path, f.read()))
					f.close()
				elif ext == '.sublime-package':
					snippets += read_zip(path)
			except:
				pass

	# Check installed Packages folder
	for root, dirs, files in os.walk(sublime.installed_packages_path()):
		for name in files:
			try:
				ext = os.path.splitext(name)[-1]
				if ext == '.sublime-package':
					path = os.path.join(root, name)
					snippets += read_zip(path)
			except:
				pass

	# Create YAML Snippets cache dir if it doesn't exist
	snippets_dir = os.path.join(sublime.packages_path(),'User', 'YAML Snippets.cache')
	if not os.path.exists(snippets_dir):
		os.makedirs(snippets_dir)

	# Unlink old snippets
	for root, dirs, files in os.walk(snippets_dir):
		for f in files:
			os.unlink(os.path.join(root, f))

	# Dump new snippets
	open(os.path.join(root, '! - AUTOGENERATED DIRECTORY - contents is regularly wiped - !'), 'a').close()
	for snippet in snippets:
		(f, path) = mkstemp(suffix='.sublime-snippet',dir=snippets_dir)
		print 'Writing YAML snippet "%s" to "%s"' % (snippet['description'], path)
		TreeDumper(snippet_to_xml(snippet)).write(path)

# Go go gadget snippets!
regenerate_snippets()
